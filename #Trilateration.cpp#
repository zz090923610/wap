//
//  Trilateration.cpp
//  mapTest
//
//  Created by ‘ÕÅ ‘îÈ on 9/11/13.
//
//

#include "Trilateration.h"

Trilateration::Trilateration()
{

	
	this->A = new double *[3];
	this->AT = new double *[3];
	this->ATA = new double *[3];
	this->ATAi = new double *[3];
	for(int loop = 0; loop < 3; loop ++)
	{
		this->A[loop]  = new double [3];
		this->AT[loop]  = new double [3];
		this->ATA[loop]  = new double [3];
		this->ATAi[loop]  = new double [3];
	}
}

Trilateration::~Trilateration()
{
	for(int loop = 0; loop < 3; loop ++)
	{
		delete this->A[loop];
		delete this->AT[loop];
		delete this->ATA[loop];
		delete this->ATAi[loop];
	}
	delete this->A;
	delete this->AT;
	delete this->ATA;
	delete this->ATAi;

}

void Trilateration::loadAPInfoFromFile(std::string path)
{
	std::list<accessPoint> :: iterator loop ;
	std::ifstream fin;
	int row = 0;
	fin.open(path.c_str(),std::ios::in);
	if(!fin.is_open())
	{
		std::cout<< "Wrong Path\n";
		fin.clear();
	}
	while(!fin.eof())
	{
		accessPoint temp;
		fin >> temp.BSSID >> temp.MAC >>temp.posX >> temp.posY >> temp.strength >> temp.timeStamp;
		row ++;
	}
	row -= 1;
	fin.clear();
	fin.close();
	fin.open(path.c_str(),std::ios::in);
	for(int loop1 = 0; loop1 < row; loop1 ++)
	{
		accessPoint temp;
		fin >> temp.BSSID >> temp.MAC >>temp.posX >> temp.posY >> temp.strength >> temp.timeStamp;
		this->apList.push_back(temp);
		
	}
	fin.clear();
	fin.close();

}

void Trilateration::selectThreeAPs()
{

}

void Trilateration::calcAPDistance()
{
	std::list<accessPoint> ::iterator loop;
	int loop1 =0;
	for(loop = this->apList.begin(); loop != this->apList.end(); loop ++)
	{
		if(loop->isSelected == true)
		{
			double GaussianNumber = 4 * gsl_ran_ugaussian_pdf(0);
			double temp = (-43 - loop->strength + GaussianNumber) / 34;
			x[loop1] = loop ->posX;
			y[loop1] = loop ->posY;
			d[loop1] = std::pow(10, temp);
		}
	
	}

}


void Trilateration::TrilaterationProcess()
{
	this->A[0][0] = 0, this->A[0][1] = 0, this->A[0][2] = 0;
	this->A[1][0] = 0, this->A[1][1] = 2*(this-> x[1] - this->x[3]), this->A[1][2] = 2*(this->y[1] - this->y[3]);
	
	this->A[2][0] = 0, this->A[2][1] = 2*(this->x[2] - this->x[3]), this->A[2][2] = 2*(this->y[2] -this->y[3]);
	
	this->AT[0][0] = 0, this->AT[0][1] = 0, this->AT[0][2] = 0;
	this->AT[1][0] = 0, this->AT[1][1] = 2*(this->x[1] - this->x[3]), this->AT[1][2] = 2*(this->x[2] - this->x[3]);
	this->AT[2][0] = 0, this->AT[2][1] = 2*(this->y[1] - this->y[3]), this->AT[2][2] = 2*(this->y[2] -this->y[3]);
	
	this->MatrixMul(this->AT, this->A, this->ATA);
	this->MatrixInverse(this->ATA, this->ATAi);
	this->MatrixMul(this->ATAi, this->AT, this->ATA);
	
	this->x[0] = this->ATA[1][1] * (this->x[1] * this->x[1] - this->x[3] * this->x[3] + this->y[1] * this->y[1] - this->y[3] * this->y[3] + this->d[2] * this->d[2] - this->d[0] * this->d[0]) +
	this->ATA[1][2] * (this->x[2] * this->x[2] - this->x[3] * this->x[3] + this->y[2] * this->y[2] - this->y[3] * this->y[3] + this->d[2] * this->d[2] - this->d[1] * this->d[1]);
	this->y[0] = this->ATA[2][1] * (this->x[1] * this->x[1] - this->x[3] * this->x[3] + this->y[1] * this->y[1] - this->y[3] * this->y[3] + this->d[2] * this->d[2] - this->d[0] * this->d[0]) +
	this->ATA[2][2] * (this->x[2] * this->x[2] - this->x[3] * this->x[3] + this->y[2] * this->y[2] - this->y[3] * this->y[3] + this->d[2] * this->d[2] - this->d[1] * this->d[1]);
	
}

void Trilateration::MatrixMul(double **mat1, double **mat2, double ** mat3)
{
	mat3[0][0] = mat1[0][0] * mat2[0][0] + mat1[0][1] * mat2[1][0] + mat1[0][2] * mat2[2][0];
	mat3[0][1] = mat1[0][0] * mat2[0][1] + mat1[0][1] * mat2[1][1] + mat1[0][2] * mat2[2][1];
	mat3[0][2] = mat1[0][0] * mat2[0][2] + mat1[0][1] * mat2[1][2] + mat1[0][2] * mat2[2][2];
	
	mat3[1][0] = mat1[1][0] * mat2[0][0] + mat1[1][1] * mat2[1][0] + mat1[1][2] * mat2[2][0];
	mat3[1][1] = mat1[1][0] * mat2[0][1] + mat1[1][1] * mat2[1][1] + mat1[1][2] * mat2[2][1];
	mat3[1][2] = mat1[1][0] * mat2[0][2] + mat1[1][1] * mat2[1][2] + mat1[1][2] * mat2[2][2];

	mat3[2][0] = mat1[2][0] * mat2[0][0] + mat1[2][1] * mat2[1][0] + mat1[2][2] * mat2[2][0];
	mat3[2][1] = mat1[2][0] * mat2[0][1] + mat1[2][1] * mat2[1][1] + mat1[2][2] * mat2[2][1];
	mat3[2][2] = mat1[2][0] * mat2[0][2] + mat1[2][1] * mat2[1][2] + mat1[2][2] * mat2[2][2];
}

void Trilateration::MatrixInverse(double **mat1, double **mat2)
{
	for(int loopx = 0; loopx < 3; loopx ++)
	{
		for(int loopy = 0; loopy < 3; loopy ++)
		{
			mat2[loopx][loopy] = mat1[loopy][loopx];
		}
	}
}







